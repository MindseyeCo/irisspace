<!DOCTYPE html> 
 <html lang="en" class="dark"> 
 <head> 
 	 <meta charset="UTF-8"> 
 	 <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"> 
 	 <title>Iris Space</title> 
 	 
 	 <meta name="apple-mobile-web-app-capable" content="yes"> 
 	 <meta name="mobile-web-app-capable" content="yes"> 
 	 <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"> 
 	 <meta name="theme-color" content="#0A0A0A"> 
 	 <link rel="manifest" href="manifest.json"> 
 	 <link rel="apple-touch-icon" href="https://placehold.co/192x192/0891b2/ffffff?text=IS"> 

 	 <script src="https://cdn.tailwindcss.com"></script> 
 	 <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script> 
 	 <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script> 
 	 <script src="https://unpkg.com/lucide@0.378.0/dist/umd/lucide.js"></script> 
     <script src="https://apis.google.com/js/api.js"></script>
     <script src="https://accounts.google.com/gsi/client"></script>

 	 <style> 
 		 @import url('https://fonts.googleapis.com/css2?family=Sora:wght@300;400;500;600&family=Playfair+Display:wght@700&display=swap'); 
 		 
 		 :root { 
 			 --cyan-glow: 0 0 8px rgba(34, 211, 238, 0.6), 0 0 16px rgba(34, 211, 238, 0.4), 0 0 24px rgba(34, 211, 238, 0.2); 
             --accent: #22D3EE; 
 			 --accent-light: #A5F3FC;
 		 } 

 		 .dark { 
 			 --bg-primary: #0A0A0A; 
 			 --bg-secondary: #101010; 
 			 --surface: #1A1A1A; 
 			 --text-primary: #E0E0E0; 
 			 --text-secondary: #A0A0A0; 
 			 --border-color: #2A2A2A; 
 			 --font-body: 'Sora', sans-serif; 
 			 --font-title: 'Playfair Display', serif; 
 		 } 
 		 
 		 body { 
 			 font-family: var(--font-body); 
 			 background-color: var(--bg-primary); 
 			 color: var(--text-primary); 
 			 overscroll-behavior: none; 
 			 transition: background-color 0.5s, color 0.5s; 
 		 } 
 		 
 		 #app-container { 
 			 background: radial-gradient(circle at 50% 50%, #1a1a1a, #0a0a0a);
             background-image: url('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"%3E%3Cg fill-rule="evenodd"%3E%3Cg fill="%231c1c1c" fill-opacity="0.4"%3E%3Cpath d="M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41-1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20l2.83 2.83-1.41 1.41L20 21.41l-2.83 2.83-1.41-1.41L18.59 20l-2.83-2.83 1.41-1.41L20 18.59z"/%3E%3C/g%3E%3C/g%3E%3C/svg%3E');
 		 } 

 		 .title-font { font-family: var(--font-title); } 

 		 .widget, .modal-pane, .timeline-item, .calendar-day, .day-detail-entry, .chat-bubble, .project-card, .note-item, .setting-card { 
 			 backdrop-filter: blur(25px) saturate(150%); 
 			 -webkit-backdrop-filter: blur(25px) saturate(150%); 
 			 background-color: rgba(26, 26, 26, 0.7); 
 			 border: 1px solid var(--border-color); 
 			 transition: all 0.3s ease; 
 		 } 
 		 
 		 .page { animation: fadeIn 0.5s ease-out forwards; } 
 		 .page.hidden { display: none; } 
 		 @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } } 

 		 @keyframes scaleIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } } 
 		 .modal-pane, .chat-bubble { animation: scaleIn 0.4s ease-out forwards; } 

 		 @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } } 
 		 .widget, .timeline-item, .project-card, .note-item, .setting-card { animation: fadeInUp 0.5s ease-out forwards; opacity: 0; animation-fill-mode: both; } 

 		 @keyframes iconPress { 0%, 100% { transform: scale(1); } 50% { transform: scale(0.85); } } 
 		 .anim-press { animation: iconPress 0.3s ease-in-out; } 

 		 .sortable-ghost { opacity: 0.4; background: var(--surface); } 

 		 ::-webkit-scrollbar { width: 5px; } 
 		 ::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 10px; } 
 		 
 		 #ai-mic-btn.is-recording, #record-audio-btn.is-recording { color: var(--accent); animation: pulse 1.5s infinite ease-in-out; } 
 		 @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } } 

 		 .image-preview-container { position: relative; display: inline-block; } 
 		 .image-preview-container img { max-height: 96px; border-radius: 0.375rem; border: 1px solid var(--border-color); } 
 		 .image-preview-remove-btn { position: absolute; top: -8px; right: -8px; background-color: var(--surface); border-radius: 9999px; padding: 2px; border: 1px solid var(--border-color); cursor: pointer; transition: color 0.2s; } 
 		 .image-preview-remove-btn:hover { color: var(--accent); } 

 		 #ai-input-visualizer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; opacity: 0; transition: opacity 0.5s ease-in-out; } 
 		 #ai-input-visualizer.is-active, #ai-input-container.is-thinking #ai-input-visualizer { opacity: 1; } 

 		 #ai-input-container.is-thinking #ai-input { animation: thinking-border 2s ease-in-out infinite; } 
 		 @keyframes thinking-border { 0%, 100% { border-color: var(--border-color); } 50% { border-color: var(--accent); box-shadow: var(--cyan-glow); } } 

 		 #ai-input-container #ai-actions > * { transition: opacity 0.3s, transform 0.3s; } 
 		 #ai-input-container.is-thinking #ai-actions > :not(#ai-thinking-icon) { opacity: 0; transform: scale(0.5); pointer-events: none; } 
 		 #ai-input-container:not(.is-thinking) #ai-thinking-icon { opacity: 0; transform: scale(0.5); pointer-events: none; } 
 		 @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } 
 		 #ai-thinking-icon { animation: spin 1s linear infinite; } 

 		 #ai-input { background-color: #101010; color: var(--text-primary); } 
 		 
 		 #ai-reply-popup {
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
            pointer-events: none;
            transition: opacity 0.4s ease, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
         }
         #ai-reply-popup.is-visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            pointer-events: auto;
         }
         #ai-reply-popup.is-flying {
            transition: transform 0.6s cubic-bezier(0.4, -0.3, 1, 1), opacity 0.6s ease-in;
         }
         .quick-reply-btn {
            background-color: var(--surface);
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
         }
         .quick-reply-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
         }

 		 .timeline-tag { background-color: var(--surface); border: 1px solid var(--border-color); padding: 2px 8px; border-radius: 99px; font-size: 0.75rem; } 
 		 .chat-bubble { max-width: 80%; width: fit-content; padding: 10px 15px; border-radius: 20px; } 
 		 .user-bubble { background-color: var(--accent); color: black; margin-left: auto; border-bottom-right-radius: 5px; } 
 		 .ai-bubble { background-color: var(--surface); border-bottom-left-radius: 5px; } 

 		 .widget-config-btn { position: absolute; top: 4px; right: 4px; color: var(--text-secondary); opacity: 0.2; transition: all 0.3s; } 
 		 .widget:hover .widget-config-btn { opacity: 1; color: var(--text-primary); }

         .nav-btn { transition: all 0.3s ease; }
         .nav-btn.active { color: var(--accent); background-color: var(--surface); }

         .note-item { cursor: pointer; }
         .project-card { cursor: pointer; }

         #dynamic-add-btn { transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }

        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--surface); transition: .4s; border-radius: 24px; border: 1px solid var(--border-color)}
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: var(--text-secondary); transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent); }
        input:checked + .slider:before { transform: translateX(20px); background-color: black; }
        
        .theme-swatch { width: 24px; height: 24px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; transition: border-color 0.2s; }
        .theme-swatch.active { border-color: white; }
 	 </style> 
 </head> 
 <body class="overflow-hidden"> 

 	 <div id="app-container" class="h-screen w-screen"> 
 	 <div id="app-overlay" class="h-full w-full"> 
 		 <div id="app-wrapper" class="h-full w-full flex flex-col max-w-7xl mx-auto"> 
 			 <header class="w-full p-4 flex justify-between items-center z-20 flex-shrink-0"> 
 				 <h1 class="title-font text-2xl font-bold text-white">Iris</h1> 
 				 <div id="header-btns" class="flex items-center space-x-2"> 
                     <button id="dynamic-add-btn" class="text-white bg-[var(--accent)] p-2 rounded-full transition-transform"><i data-lucide="plus"></i></button>
                     <button id="settings-btn" data-view="settings-view" class="text-[var(--text-secondary)] hover:text-white p-2 rounded-full transition-colors"><i data-lucide="settings"></i></button>
 					 <button id="widget-settings-btn" class="text-[var(--text-secondary)] hover:text-white p-2 rounded-full transition-colors"><i data-lucide="layout-template"></i></button> 
 					 <button id="search-btn" class="text-[var(--text-secondary)] hover:text-white p-2 rounded-full transition-colors"><i data-lucide="search"></i></button> 
 				 </div> 
 			 </header> 

 			 <main id="main-content" class="flex-grow p-4 overflow-y-auto relative"> 
 				 <div id="homescreen-view" class="page h-full"><div id="widget-grid" class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-4"></div></div> 
 				 <div id="timeline-view" class="page hidden"><div id="timeline-container" class="space-y-4"></div></div> 
 				 <div id="projects-view" class="page hidden"><div id="projects-container" class="space-y-4"></div></div>
 				 <div id="notes-view" class="page hidden"><div id="notes-container" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"></div></div>
 				 <div id="chat-view" class="page hidden flex flex-col h-full"><div id="chat-container" class="space-y-4 flex-grow overflow-y-auto"></div></div> 
                 <div id="settings-view" class="page hidden"><div id="settings-container" class="space-y-4"></div></div>
                 <div id="note-detail-view" class="page hidden"></div>
                 <div id="project-detail-view" class="page hidden"></div>
 			 </main> 
 			 
 			 <div id="ai-input-container" class="w-full p-4 flex-shrink-0 z-10"> 
 				 <div id="ai-image-preview-container" class="w-full max-w-2xl mx-auto flex justify-center mb-2"></div> 
 				 <div class="relative w-full max-w-2xl mx-auto"> 
 					 <canvas id="ai-input-visualizer"></canvas> 
 					 <input type="text" id="ai-input" placeholder="Talk to Iris..." class="relative w-full bg-[var(--surface)]/80 backdrop-blur-sm border border-[var(--border-color)] rounded-full py-3 pl-14 pr-28 text-base focus:outline-none focus:border-[var(--accent)] transition-all duration-300"> 
 					 <label for="ai-file-input" class="absolute left-3 top-1/2 -translate-y-1/2 text-[var(--text-secondary)] hover:text-[var(--accent)] p-2 rounded-full cursor-pointer z-10"> 
 						 <i data-lucide="paperclip" class="w-6 h-6"></i> 
 					 </label> 
 					 <input type="file" id="ai-file-input" class="hidden" accept="image/*"> 
 					 <div id="ai-actions" class="absolute right-3 top-1/2 -translate-y-1/2 flex items-center z-10 h-full"> 
 						 <button id="ai-mic-btn" class="text-[var(--text-secondary)] hover:text-[var(--accent)] p-2 rounded-full"> 
 							 <i data-lucide="mic" class="w-6 h-6"></i> 
 						 </button> 
 						 <button id="ai-send-btn" class="text-[var(--text-secondary)] hover:text-[var(--accent)] p-2 rounded-full"> 
 							 <i data-lucide="send" class="w-6 h-6"></i> 
 						 </button> 
 						 <div id="ai-thinking-icon" class="text-[var(--accent)] p-2 absolute right-0"><i data-lucide="loader-circle" class="w-6 h-6"></i></div> 
 					 </div> 
 				 </div> 
 			 </div> 

 			 <footer class="w-full p-2 flex justify-center items-center z-20 flex-shrink-0"> 
                <div class="flex items-center space-x-1 sm:space-x-2 bg-black/30 backdrop-blur-md border border-[var(--border-color)] p-1 sm:p-2 rounded-full">
 				 <button data-view="homescreen-view" class="nav-btn active p-2 sm:px-4 sm:py-2 rounded-full flex items-center"><i data-lucide="layout-grid"></i><span class="hidden sm:inline ml-2">Home</span></button> 
 				 <button data-view="timeline-view" class="nav-btn p-2 sm:px-4 sm:py-2 rounded-full flex items-center"><i data-lucide="list-ordered"></i><span class="hidden sm:inline ml-2">Timeline</span></button> 
 				 <button data-view="projects-view" class="nav-btn p-2 sm:px-4 sm:py-2 rounded-full flex items-center"><i data-lucide="case-sensitive"></i><span class="hidden sm:inline ml-2">Projects</span></button> 
 				 <button data-view="notes-view" class="nav-btn p-2 sm:px-4 sm:py-2 rounded-full flex items-center"><i data-lucide="notebook-tabs"></i><span class="hidden sm:inline ml-2">Notes</span></button> 
 				 <button data-view="chat-view" id="footer-chat-btn" class="nav-btn p-2 sm:px-4 sm:py-2 rounded-full flex items-center"><i data-lucide="message-square"></i><span class="hidden sm:inline ml-2">Chat</span></button> 
                </div>
 			 </footer> 
 		 </div> 
 		 
 		 <div id="modal-backdrop" class="hidden fixed inset-0 bg-black/60 z-40"></div> 
 		 
 		 <div id="ai-reply-popup" class="fixed bottom-36 left-1/2 w-full max-w-sm p-4 z-[100] -translate-x-1/2"> 
 			 <div class="modal-pane p-3"> 
 				 <div id="ai-reply-content">
                     <div class="flex items-center"> 
                         <div class="bg-cyan-500/20 p-2 rounded-full"><i data-lucide="sparkles" class="w-6 h-6 text-[var(--accent)]"></i></div> 
                         <div class="ml-3"><p id="ai-reply-text" class="text-sm font-medium text-[var(--text-primary)]"></p></div> 
                     </div>
                 </div>
 			 </div> 
 		 </div> 

 		 <!-- MODALS --> 
 		 <div id="search-modal" class="hidden fixed inset-0 flex flex-col items-center justify-center z-50 p-4"></div> 
 		 <div id="create-moment-modal" class="hidden fixed inset-0 flex flex-col items-center justify-center z-50 p-4"></div> 
 		 <div id="widget-settings-modal" class="hidden fixed inset-0 flex items-center justify-center z-50 p-4"></div> 
 		 <div id="widget-config-modal" class="hidden fixed inset-0 flex flex-col items-center justify-center z-50 p-4"></div> 
 	 </div> 
 	 </div> 

 	 <script type="module"> 
 		 // --- INITIALIZATION --- 
 		 const { jsPDF } = window.jspdf; 
 		 const DB_NAME = 'IrisSpaceDB', DB_VERSION = 11; 
 		 const MOMENTS_STORE = 'moments', WIDGET_STORE = 'widgets', SETTINGS_STORE = 'settings', TASKS_STORE = 'tasks', CHAT_HISTORY_STORE = 'chatHistory', PROJECTS_STORE = 'projects', NOTES_STORE = 'notes', QUICK_NOTES_STORE = 'quickNotes'; 
 		 
         const GOOGLE_API_KEY = "YOUR_GOOGLE_API_KEY_HERE";
         const GOOGLE_CLIENT_ID = "YOUR_GOOGLE_CLIENT_ID_HERE.apps.googleusercontent.com";
 		 const GEMINI_API_KEY = "AIzaSyAnmS4y8qRL-bquwc6FZbZ6OZFqrADgwx0";

 		 let db, aiImageBase64 = null, aiImageMimeType = null, pendingAICommand = null; 
 		 let conversationHistory = [];
         let gapiInited = false, gsiInited = false, tokenClient;
 		 
 		 window.onload = async () => { 
 			 lucide.createIcons(); 
 			 setupAIVisualizer(); 
 			 try { 
 				 db = await openDB(); 
 				 renderAllModals(); 
 				 setupEventListeners(); 
 				 setupSpeechRecognition(); 
                 handleClientLoad(); // Init Google Services
                 await applyTheme();
 				 await refreshApp(); 
 				 showView('homescreen-view'); 
                 setInterval(checkNotifications, 3600000); // Check every hour
 			 } catch (error) { console.error('Failed to initialize app:', error); } 
 		 }; 

 		 // --- HAPTICS --- 
 		 function hapticFeedback(style = 'light') { if ('vibrate' in navigator) navigator.vibrate({ light: [50], medium: [100], heavy: [150] }[style] || [50]); } 

 		 // --- DATABASE --- 
 		 function openDB() { 
 			 return new Promise((resolve, reject) => { 
 				 const request = indexedDB.open(DB_NAME, DB_VERSION); 
 				 request.onerror = () => reject('DB Error'); 
 				 request.onsuccess = (e) => resolve(e.target.result); 
 				 request.onupgradeneeded = (e) => { 
 					 let db = e.target.result; 
 					 if (!db.objectStoreNames.contains(MOMENTS_STORE)) db.createObjectStore(MOMENTS_STORE, { keyPath: 'id', autoIncrement: true }); 
 					 if (!db.objectStoreNames.contains(WIDGET_STORE)) db.createObjectStore(WIDGET_STORE, { keyPath: 'id' }); 
 					 if (!db.objectStoreNames.contains(SETTINGS_STORE)) db.createObjectStore(SETTINGS_STORE, { keyPath: 'key' }); 
 					 if (!db.objectStoreNames.contains(TASKS_STORE)) {
                        const taskStore = db.createObjectStore(TASKS_STORE, { keyPath: 'id', autoIncrement: true });
                        taskStore.createIndex('createdAt', 'createdAt', { unique: false });
                     }
 					 if (!db.objectStoreNames.contains(CHAT_HISTORY_STORE)) db.createObjectStore(CHAT_HISTORY_STORE, { keyPath: 'id', autoIncrement: true }); 
                     if (!db.objectStoreNames.contains(PROJECTS_STORE)) {
                        const projectStore = db.createObjectStore(PROJECTS_STORE, { keyPath: 'id', autoIncrement: true });
                        projectStore.createIndex('name', 'name', { unique: false });
                     }
                     if (!db.objectStoreNames.contains(NOTES_STORE)) db.createObjectStore(NOTES_STORE, { keyPath: 'id', autoIncrement: true });
                     if (!db.objectStoreNames.contains(QUICK_NOTES_STORE)) db.createObjectStore(QUICK_NOTES_STORE, { keyPath: 'id' });
 				 }; 
 			 }); 
 		 } 
 		 const dbAction = (storeName, mode, action) => new Promise((resolve, reject) => { 
 			  const tx = db.transaction(storeName, mode); 
 			  const store = tx.objectStore(storeName); 
 			  const request = action(store); 
 			  request.onsuccess = (e) => resolve(e.target.result); 
 			  request.onerror = (e) => reject(e.target.error); 
 		 }); 

 		 // --- CORE & UI --- 
 		 async function refreshApp() { 
 			 await Promise.all([renderWidgets(), renderTimeline(), renderProjects(), renderNotes(), renderChatHistory(), renderSettings()]); 
 		 } 
 		 function showView(viewId) {
            const addBtn = document.getElementById('dynamic-add-btn');
 			 document.querySelectorAll('.page').forEach(p => p.classList.add('hidden')); 
 			 const view = document.getElementById(viewId);
             if (view) view.classList.remove('hidden'); 
 			 document.querySelectorAll('.nav-btn').forEach(btn => { 
                 btn.classList.toggle('active', btn.dataset.view === viewId);
 			 });
             document.querySelectorAll('#header-btns button').forEach(btn => {
                btn.classList.toggle('text-[var(--accent)]', btn.dataset.view === viewId);
             });
             addBtn.style.transform = 'rotate(0deg)';
             let icon = 'plus';
             switch(viewId) {
                case 'timeline-view': icon = 'pen-square'; break;
                case 'projects-view': icon = 'folder-plus'; break;
                case 'notes-view': icon = 'file-plus-2'; break;
             }
             addBtn.innerHTML = `<i data-lucide="${icon}"></i>`;
             lucide.createIcons();
 		 } 
 		 function animateIcon(element) { if (!element) return; hapticFeedback('light'); element.classList.add('anim-press'); element.addEventListener('animationend', () => element.classList.remove('anim-press'), { once: true }); } 
 		 function showModal(id) { document.getElementById('modal-backdrop').classList.remove('hidden'); document.getElementById(id).classList.remove('hidden'); } 
 		 function closeModal(id) { document.getElementById('modal-backdrop').classList.add('hidden'); document.getElementById(id).classList.add('hidden'); } 
 		 
        let replyTimeout;
        function showAIReply(text, options = {}) {
            const { animateToChat = false, quickReplies = [] } = options;
            const popup = document.getElementById('ai-reply-popup');
            const contentEl = document.getElementById('ai-reply-content');
            
            clearTimeout(replyTimeout);

            popup.classList.remove('is-flying');
            popup.style.transform = '';
            popup.style.opacity = '';
            
            let displayText = text;
            if (displayText && displayText.length > 100 && !quickReplies.length) {
                displayText = displayText.substring(0, 97) + '...';
            }

            let quickReplyHTML = '';
            if (quickReplies.length > 0) {
                quickReplyHTML = `<div class="mt-3 flex justify-end gap-2">
                    ${quickReplies.slice(0, 2).map(reply => `<button class="quick-reply-btn text-xs px-3 py-1 rounded-full" data-reply="${reply}">${reply}</button>`).join('')}
                </div>`;
            }

            contentEl.innerHTML = `
                <div class="flex items-start"> 
                     <div class="bg-cyan-500/20 p-2 rounded-full flex-shrink-0"><i data-lucide="sparkles" class="w-6 h-6 text-[var(--accent)]"></i></div> 
                     <div class="ml-3"><p id="ai-reply-text" class="text-sm font-medium text-[var(--text-primary)]">${displayText}</p></div> 
                </div>
                ${quickReplyHTML}
            `;
            lucide.createIcons();
            
            void popup.offsetWidth;

            popup.classList.add('is-visible');

            if (quickReplies.length > 0) {
                document.querySelectorAll('.quick-reply-btn').forEach(btn => {
                    btn.addEventListener('click', () => handleQuickReply(btn.dataset.reply));
                });
            } else {
                replyTimeout = setTimeout(() => {
                    popup.classList.remove('is-visible');
                }, 4000);
            }
        }

 		 // --- MODAL RENDERING --- 
 		 function renderAllModals() { 
 			 document.getElementById('search-modal').innerHTML = `<div class="modal-pane w-full max-w-2xl max-h-[80vh] rounded-lg flex flex-col"><div class="p-4 border-b border-[var(--border-color)] flex justify-between items-center"><h2 class="title-font text-xl">Search</h2><button class="close-modal-btn p-1" data-modal="search-modal"><i data-lucide="x"></i></button></div><div class="p-4 border-b border-[var(--border-color)]"><div class="relative"><i data-lucide="search" class="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-[var(--text-secondary)]"></i><input type="text" id="search-input" placeholder="Search moments, notes, projects..." class="w-full bg-transparent pl-10 pr-4 py-2 rounded-lg focus:outline-none"></div></div><div id="search-results" class="flex-grow overflow-y-auto p-4 space-y-3"></div></div>`; 
 			 document.getElementById('create-moment-modal').innerHTML = `<div class="modal-pane w-full max-w-md rounded-lg flex flex-col"><div class="p-4 border-b border-[var(--border-color)] flex justify-between items-center"><h2 class="title-font text-xl">Create Moment</h2><button class="close-modal-btn p-1" data-modal="create-moment-modal"><i data-lucide="x"></i></button></div><div class="p-4 space-y-4"><div id="moment-image-preview-container" class="w-full flex justify-center mb-2"></div><div id="moment-audio-preview-container" class="w-full flex justify-center mb-2"></div><textarea id="moment-text-input" placeholder="What's on your mind?" class="w-full h-24 bg-transparent p-2 rounded border border-[var(--border-color)] focus:outline-none focus:border-[var(--accent)]"></textarea><input type="text" id="moment-tags-input" placeholder="Tags (comma separated)" class="w-full bg-transparent p-2 rounded border border-[var(--border-color)] focus:outline-none focus:border-[var(--accent)]"><div class="flex justify-between items-center"><label for="moment-file-input" class="cursor-pointer p-2 rounded border border-[var(--border-color)] hover:border-[var(--accent)]"><i data-lucide="paperclip" class="inline"></i> Attach</label><input type="file" id="moment-file-input" class="hidden" accept="image/*,video/*"><button id="record-audio-btn" class="p-2 rounded border border-[var(--border-color)] hover:border-[var(--accent)] transition-all"><i data-lucide="mic" class="inline"></i> Record</button></div></div><div class="p-4 border-t border-[var(--border-color)] text-right"><button id="save-moment-btn" class="px-4 py-2 bg-[var(--accent)] text-black rounded font-semibold hover:opacity-80 transition">Save</button></div></div>`; 
 			 document.getElementById('widget-settings-modal').innerHTML = `<div class="modal-pane w-full max-w-2xl rounded-lg flex flex-col max-h-[80vh]"><div class="p-4 border-b border-[var(--border-color)] flex justify-between items-center"><h2 class="title-font text-xl">Manage Widgets</h2><button class="close-modal-btn p-1" data-modal="widget-settings-modal"><i data-lucide="x"></i></button></div><div class="flex-grow overflow-y-auto p-4 grid grid-cols-1 md:grid-cols-2 gap-4"><div><h3 class="font-semibold mb-2">Active Widgets</h3><div id="active-widgets-list" class="min-h-[200px] bg-[var(--bg-secondary)] p-2 rounded-md space-y-2"></div></div><div><h3 class="font-semibold mb-2">Available Widgets</h3><div id="available-widgets-list" class="min-h-[200px] bg-[var(--bg-secondary)] p-2 rounded-md space-y-2"></div></div></div><div class="p-4 border-t border-[var(--border-color)] text-right"><button id="save-widgets-btn" class="px-4 py-2 bg-[var(--accent)] text-black rounded font-semibold hover:opacity-80 transition">Save & Close</button></div></div>`; 
 			 document.getElementById('widget-config-modal').innerHTML = `<div class="modal-pane w-full max-w-md rounded-lg flex flex-col"><div class="p-4 border-b border-[var(--border-color)] flex justify-between items-center"><h2 id="widget-config-title" class="title-font text-xl"></h2><button class="close-modal-btn p-1" data-modal="widget-config-modal"><i data-lucide="x"></i></button></div><div id="widget-config-content" class="p-4 space-y-4"></div><div class="p-4 border-t border-[var(--border-color)] text-right"><button id="save-widget-config-btn" class="px-4 py-2 bg-[var(--accent)] text-black rounded font-semibold hover:opacity-80 transition">Save</button></div></div>`; 
             lucide.createIcons(); 
 		 } 
 		 
 		 // --- EVENT LISTENERS --- 
 		 function setupEventListeners() { 
 			 document.body.addEventListener('click', async e => { 
 				 const navBtn = e.target.closest('.nav-btn'); 
 				 if (navBtn) { showView(navBtn.dataset.view); } 

 				 const deleteBtn = e.target.closest('.delete-moment-btn');  
 				 if (deleteBtn) deleteMoment(parseInt(deleteBtn.dataset.momentId, 10)); 

 				 const taskCheckbox = e.target.closest('.task-checkbox');  
 				 if(taskCheckbox) {
                    const taskId = parseInt(taskCheckbox.dataset.taskId);
                    const projectId = taskCheckbox.dataset.projectId;
                    toggleTaskCompletion(taskId, taskCheckbox.checked, projectId);
                 }

 				 const widgetConfigBtn = e.target.closest('.widget-config-btn');  
 				 if(widgetConfigBtn) openWidgetConfigModal(widgetConfigBtn.dataset.widgetId);

                 const noteItem = e.target.closest('.note-item');
                 if (noteItem) openNoteView(parseInt(noteItem.dataset.noteId));

                 const projectCard = e.target.closest('.project-card');
                 if (projectCard) openProjectView(parseInt(projectCard.dataset.projectId));

                 const closeModalBtn = e.target.closest('.close-modal-btn');
                 if(closeModalBtn) closeModal(closeModalBtn.dataset.modal);

                 const searchResultItem = e.target.closest('.search-result-item');
                 if(searchResultItem) handleSearchResultClick(searchResultItem.dataset);

                 const themeSwatch = e.target.closest('.theme-swatch');
                 if(themeSwatch) saveTheme(themeSwatch.dataset.color);
 			 });

            document.getElementById('search-input').addEventListener('input', (e) => performSearch(e.target.value));

 			 document.getElementById('settings-btn').addEventListener('click', () => showView('settings-view')); 
 			 document.getElementById('search-btn').addEventListener('click', () => { showModal('search-modal'); hapticFeedback('light'); document.getElementById('search-input').focus(); }); 
 			 document.getElementById('dynamic-add-btn').addEventListener('click', handleDynamicAdd);
 			 document.getElementById('widget-settings-btn').addEventListener('click', () => { showModal('widget-settings-modal'); populateWidgetModal(); hapticFeedback('light'); }); 
 			 document.getElementById('modal-backdrop').addEventListener('click', () => { ['search-modal', 'create-moment-modal', 'widget-settings-modal', 'widget-config-modal'].forEach(closeModal); }); 
 			 
 			 document.getElementById('save-moment-btn').addEventListener('click', () => saveMoment()); 
 			 document.getElementById('moment-file-input').addEventListener('change', handleMomentFileSelect); 
 			 document.getElementById('record-audio-btn').addEventListener('click', toggleAudioRecording); 
 			 document.getElementById('save-widgets-btn').addEventListener('click', saveWidgetLayout); 
 			 document.getElementById('ai-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') processCommand(e.target.value); }); 
 			 document.getElementById('ai-send-btn').addEventListener('click', () => { processCommand(document.getElementById('ai-input').value); animateIcon(document.querySelector('#ai-send-btn i')); }); 
 			 document.getElementById('ai-file-input').addEventListener('change', handleAIFileSelect); 
 		 } 
 		 
         // --- DYNAMIC ADD BUTTON HANDLER ---
         function handleDynamicAdd() {
            const addBtn = document.getElementById('dynamic-add-btn');
            addBtn.style.transform = 'rotate(90deg)';
            setTimeout(() => addBtn.style.transform = 'rotate(0deg)', 400);

            const currentView = document.querySelector('.page:not(.hidden)').id;
            switch(currentView) {
                case 'notes-view':
                    openNoteView(null); // Open view for new note
                    break;
                case 'projects-view':
                    document.getElementById('ai-input').focus();
                    showAIReply("What should I name the new project?");
                    break;
                case 'timeline-view':
                case 'homescreen-view':
                default:
                    showModal('create-moment-modal');
                    break;
            }
         }

 		 // --- PERMISSIONS & SETTINGS ---
         async function renderSettings() {
            const container = document.getElementById('settings-container');
            container.innerHTML = `<h2 class="title-font text-3xl font-bold mb-6">Settings</h2>`;
            const notifPerm = 'Notification' in window ? Notification.permission : 'denied';
            const locPerm = localStorage.getItem('locationPermission') || 'prompt';
            const googleToken = localStorage.getItem('google_token');

            const settings = [
                { id: 'notifications', name: 'Task Reminders', desc: 'Get notified for tasks over 12 hours old.', status: notifPerm },
                { id: 'location', name: 'Location Access', desc: 'Allow access to improve weather accuracy.', status: locPerm },
                { id: 'google', name: 'Google Calendar', desc: googleToken ? 'Connected. Tasks will sync.' : 'Connect to sync tasks and events.', status: googleToken ? 'granted' : 'prompt' }
            ];
            
            let settingsHTML = settings.map((s, index) => {
                const isChecked = s.status === 'granted';
                const isDisabled = s.status === 'denied';
                return `<div class="setting-card p-4 rounded-lg flex justify-between items-center" style="animation-delay: ${index * 50}ms">
                    <div>
                        <h3 class="font-semibold">${s.name} ${isDisabled ? '<span class="text-xs text-red-400">(Blocked)</span>' : ''}</h3>
                        <p class="text-sm text-[var(--text-secondary)]">${s.desc}</p>
                    </div>
                    <label class="switch">
                        <input type="checkbox" class="permission-toggle" data-permission-type="${s.id}" ${isChecked ? 'checked' : ''} ${isDisabled ? 'disabled' : ''}>
                        <span class="slider"></span>
                    </label>
                </div>`;
            }).join('');

            const themes = [ {name: 'Cyan', color: '#22D3EE'}, {name: 'Rose', color: '#F43F5E'}, {name: 'Amber', color: '#F59E0B'}, {name: 'Lime', color: '#84CC16'}];
            const currentTheme = localStorage.getItem('themeColor') || '#22D3EE';
            settingsHTML += `<div class="setting-card p-4 rounded-lg" style="animation-delay: ${settings.length * 50}ms">
                <h3 class="font-semibold mb-3">Theme Color</h3>
                <div class="flex items-center gap-4">
                    ${themes.map(t => `<div class="theme-swatch ${currentTheme === t.color ? 'active' : ''}" data-color="${t.color}" style="background-color: ${t.color}"></div>`).join('')}
                </div>
            </div>`;

            container.innerHTML += settingsHTML;

            document.querySelectorAll('.permission-toggle').forEach(toggle => {
                toggle.addEventListener('change', (e) => handlePermissionToggle(e.target.dataset.permissionType, e.target.checked));
            });
         }

         async function handlePermissionToggle(type, enabled) {
            if (type === 'notifications') {
                if (enabled && Notification.permission !== 'granted') {
                    const permission = await Notification.requestPermission();
                    if (permission !== 'granted') {
                        document.querySelector('[data-permission-type="notifications"]').checked = false;
                    }
                } 
            } else if (type === 'location') {
                if (enabled) {
                    if ('geolocation' in navigator) {
                        try {
                            await new Promise((resolve, reject) => navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 5000 }));
                            localStorage.setItem('locationPermission', 'granted');
                        } catch (error) {
                            console.error("Geolocation permission denied.", error);
                            localStorage.setItem('locationPermission', 'denied');
                            document.querySelector('[data-permission-type="location"]').checked = false;
                        }
                    }
                } else {
                    localStorage.setItem('locationPermission', 'denied');
                }
            } else if (type === 'google') {
                if (enabled) {
                    handleAuthClick();
                } else {
                    handleSignoutClick();
                }
            }
            await refreshApp();
         }

         async function saveTheme(color) {
            localStorage.setItem('themeColor', color);
            await applyTheme();
            await renderSettings(); // Re-render to update active swatch
         }

         async function applyTheme() {
            const color = localStorage.getItem('themeColor') || '#22D3EE';
            document.documentElement.style.setProperty('--accent', color);
         }

 		 // --- MOMENTS, MEDIA, CHAT --- 
 		 let mediaRecorder, audioChunks = [], audioBlob = null, momentImageBlob = null; 
 		 async function toggleAudioRecording() {
            const recordBtn = document.getElementById('record-audio-btn');
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                recordBtn.classList.remove('is-recording');
                recordBtn.innerHTML = '<i data-lucide="mic" class="inline"></i> Record';
                lucide.createIcons();
            } else {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                    mediaRecorder.onstop = () => {
                        audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        const audioUrl = URL.createObjectURL(audioBlob);
                        document.getElementById('moment-audio-preview-container').innerHTML = `<audio controls src="${audioUrl}" class="w-full"></audio>`;
                        stream.getTracks().forEach(track => track.stop());
                    };
                    mediaRecorder.start();
                    recordBtn.classList.add('is-recording');
                    recordBtn.innerHTML = '<i data-lucide="stop-circle" class="inline"></i> Stop';
                    lucide.createIcons();
                } catch (err) {
                    console.error("Error accessing microphone:", err);
                    showAIReply("Could not access the microphone. Please grant permission in settings.");
                }
            }
        } 
 		 async function saveMoment(fromAI = false, aiText = '') { 
            const textInput = document.getElementById('moment-text-input');
            const text = fromAI ? aiText : textInput.value;
            const tagsInput = document.getElementById('moment-tags-input');
            const tags = tagsInput.value.split(',').map(t => t.trim()).filter(Boolean);
            
            if (!text && !momentImageBlob && !audioBlob) return;

            const moment = { text, tags, timestamp: Date.now() };

            if (momentImageBlob) {
                moment.data = momentImageBlob;
                moment.type = 'image';
            } else if (audioBlob) {
                moment.data = audioBlob;
                moment.type = 'audio';
            }

            await dbAction(MOMENTS_STORE, 'readwrite', store => store.add(moment));
            
            if (!fromAI) {
                textInput.value = '';
                tagsInput.value = '';
                momentImageBlob = null;
                audioBlob = null;
                document.getElementById('moment-image-preview-container').innerHTML = '';
                document.getElementById('moment-audio-preview-container').innerHTML = '';
                closeModal('create-moment-modal');
            }
            
            await refreshApp();
        } 
 		 async function renderTimeline() { 
 			 const container = document.getElementById('timeline-container'); 
 			 container.innerHTML = `<h2 class="title-font text-3xl font-bold mb-6">Timeline</h2>`; 
 			 const moments = await dbAction(MOMENTS_STORE, 'readonly', store => store.getAll()); 
 			 moments.sort((a,b) => b.timestamp - a.timestamp); 
 			 if(moments.length === 0) { container.innerHTML += `<div class="text-center mt-20 text-[var(--text-secondary)]"><i data-lucide="moon-star" class="w-16 h-16 mx-auto"></i><p class="mt-4">Your space is clear. Create a moment.</p></div>`; lucide.createIcons(); return; } 
 			 
 			 moments.forEach((m, index) => { 
 				 let mediaContent = '', icon = 'pen-square'; 
 				 if (m.data) { 
 					 const mediaUrl = URL.createObjectURL(m.data); 
 					 if (m.type === 'image') { mediaContent = `<img src="${mediaUrl}" class="mt-2 rounded-lg max-h-60 w-auto">`; icon = 'image'; } 
 					 if (m.type === 'video') { mediaContent = `<video controls src="${mediaUrl}" class="mt-2 rounded-lg w-full"></video>`; icon = 'video'; } 
 					 if (m.type === 'audio') { mediaContent = `<audio controls src="${mediaUrl}" class="w-full mt-2"></audio>`; icon = 'mic'; } 
 				 } 
 				 const tagsHTML = m.tags && m.tags.length ? `<div class="flex flex-wrap gap-2 mt-3">${m.tags.map(t => `<span class="timeline-tag">${t}</span>`).join('')}</div>` : ''; 
 				 const item = document.createElement('div'); 
 				 item.className = 'timeline-item p-4 rounded-lg relative'; 
 				 item.style.animationDelay = `${index * 50}ms`; 
 				 item.innerHTML = ` 
 					 <button class="delete-moment-btn absolute top-2 right-2 p-1 text-[var(--text-secondary)] hover:text-red-500 transition-colors" data-moment-id="${m.id}"><i data-lucide="trash-2" class="w-4 h-4"></i></button> 
 					 <p class="whitespace-pre-wrap pr-8">${m.text || ''}</p>  
 					 ${mediaContent} ${tagsHTML} 
 					 <div class="text-xs text-[var(--text-secondary)] mt-3 pt-2 border-t border-[var(--border-color)] flex justify-between items-center"> 
 						 <span><i data-lucide="${icon}" class="inline-block w-3 h-3 mr-1"></i>${new Date(m.timestamp).toLocaleString()}</span> 
 					 </div>`; 
 				 container.appendChild(item); 
 			 }); 
 			 lucide.createIcons(); 
 		 } 
 		 async function deleteMoment(momentId) { await dbAction(MOMENTS_STORE, 'readwrite', store => store.delete(momentId)); await refreshApp(); } 
 		 function handleMomentFileSelect(event) { 
             const file = event.target.files[0];
             if (!file) return;
             momentImageBlob = file;
             audioBlob = null; 
             document.getElementById('moment-audio-preview-container').innerHTML = '';
             const reader = new FileReader();
             reader.onload = (e) => {
                 document.getElementById('moment-image-preview-container').innerHTML = `<img src="${e.target.result}" class="max-h-24 rounded border border-[var(--border-color)]">`;
             };
             reader.readAsDataURL(file);
         } 
 		 async function saveToChatHistory(userQuery, aiResponse) { 
 			 const entry = { timestamp: Date.now(), userQuery, aiResponse }; 
 			 await dbAction(CHAT_HISTORY_STORE, 'readwrite', store => store.add(entry)); 
             conversationHistory.push({ role: 'user', parts: [{ text: userQuery }] });
             conversationHistory.push({ role: 'model', parts: [{ text: aiResponse }] });
             if (conversationHistory.length > 4) conversationHistory = conversationHistory.slice(-4);
 			 await renderChatHistory(); 
 		 } 
 		 async function renderChatHistory() { 
 			 const container = document.getElementById('chat-container'); 
 			 container.innerHTML = ''; 
 			 const history = await dbAction(CHAT_HISTORY_STORE, 'readonly', store => store.getAll()); 
 			 if(history.length === 0) { container.innerHTML = `<div class="text-center mt-20 text-[var(--text-secondary)]"><i data-lucide="bot" class="w-16 h-16 mx-auto"></i><p class="mt-4">Your chat history is empty. <br/> Ask Iris anything!</p></div>`; lucide.createIcons(); return; } 
 			 history.forEach(entry => { 
 				 container.innerHTML += ` 
 					 <div class="chat-bubble user-bubble"><p>${entry.userQuery}</p></div> 
 					 <div class="chat-bubble ai-bubble"><p>${entry.aiResponse}</p></div>`; 
 			 }); 
 			 container.scrollTop = container.scrollHeight; 
 		 } 

 		 // --- WIDGETS --- 
 		 const ALL_WIDGETS = { 
 			 irisBrief: { name: "Iris Brief", render: async () => { 
 				 const tasks = await dbAction(TASKS_STORE, 'readonly', store => store.getAll()); 
 				 const todaysTasks = tasks.filter(t => !t.completed); 
 				 const countdown = await dbAction(SETTINGS_STORE, 'readonly', store => store.get('countdown')); 
 				 let countdownText = ''; 
 				 if (countdown && countdown.date) { 
 					 const targetDate = new Date(countdown.date); 
 					 const diff = targetDate - new Date(); 
                     if (diff > 0) {
                        const daysLeft = Math.ceil(diff / (1000 * 60 * 60 * 24)); 
                        countdownText = `<div class="text-xs"><i data-lucide="calendar-clock" class="inline w-3 h-3 mr-1"></i><strong>${daysLeft}</strong> days until ${countdown.event}</div>`; 
                     }
 				 } 
 				 const taskText = `<div class="text-xs"><i data-lucide="check-circle" class="inline w-3 h-3 mr-1"></i>You have <strong>${todaysTasks.length}</strong> pending task${todaysTasks.length !== 1 ? 's' : ''}.</div>`; 
 				 return ` 
 					 <div class="text-left w-full space-y-2"> 
 						 <h3 class="font-bold text-base">Your Briefing</h3> 
 						 ${taskText} 
 						 ${countdownText} 
 						 <div class="text-xs pt-1 border-t border-[var(--border-color)]/50"><i data-lucide="sparkles" class="inline w-3 h-3 mr-1"></i>Have a productive day!</div> 
 					 </div> 
 				 `; 
 			 }}, 
              weather: { name: "Weather", configurable: true, render: async () => {
                const weatherData = await getWeatherData();
                if (weatherData === 'denied') return `<div class="text-sm text-[var(--text-secondary)]">Location access denied.</div>`
                if (!weatherData) return `<div class="text-sm text-[var(--text-secondary)]">Weather unavailable.</div>`;
                const { temp, description, icon } = weatherData;
                return `<div class="flex items-center justify-center gap-4">
                            <img src="${icon}" alt="${description}" class="w-16 h-16"/>
                            <div>
                                <p class="text-4xl font-bold">${temp}°F</p>
                                <p class="text-sm capitalize">${description}</p>
                            </div>
                        </div>`;
             }},
 			 clock: { name: "Clock", render: () => `<div class="text-4xl font-bold">${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>` }, 
 			 tasks: { name: "Tasks", size: 'col-span-2 row-span-2', render: async () => {
                const tasks = await dbAction(TASKS_STORE, 'readonly', store => store.getAll());
                const pendingTasks = tasks.filter(t => !t.completed);
                const completedCount = tasks.length - pendingTasks.length;
                const progress = tasks.length > 0 ? (completedCount / tasks.length) * 100 : 0;
                
                const size = 100;
                const strokeWidth = 10;
                const center = size / 2;
                const radius = center - strokeWidth;
                const circumference = 2 * Math.PI * radius;
                const offset = circumference - (progress / 100) * circumference;

                let taskListHTML = `<div class="text-center text-sm text-[var(--text-secondary)] mt-4">All tasks complete!</div>`;
                if(pendingTasks.length > 0) {
                    taskListHTML = pendingTasks.slice(0, 4).map(t => `
                        <div class="flex items-center gap-2">
                            <input type="checkbox" data-task-id="${t.id}" class="task-checkbox accent-[var(--accent)]">
                            <label>${t.text}</label>
                        </div>
                    `).join('');
                }

                return `<div class="text-left w-full h-full flex flex-col p-2">
                    <div class="flex items-start justify-between">
                         <div>
                            <h3 class="font-bold text-base">Today's Tasks</h3>
                            <p class="text-xs text-[var(--text-secondary)]">${completedCount} of ${tasks.length} complete</p>
                         </div>
                         <svg class="w-16 h-16" viewBox="0 0 ${size} ${size}">
                            <circle class="text-black/20" stroke-width="${strokeWidth}" stroke="currentColor" fill="transparent" r="${radius}" cx="${center}" cy="${center}"/>
                            <circle class="text-[var(--accent)]" stroke-width="${strokeWidth}" stroke-dasharray="${circumference}" stroke-dashoffset="${offset}"
                                stroke-linecap="round" stroke="currentColor" fill="transparent" r="${radius}" cx="${center}" cy="${center}"
                                style="transition: stroke-dashoffset 0.5s; transform: rotate(-90deg); transform-origin: 50% 50%;" />
                            <text x="50%" y="50%" text-anchor="middle" dy=".3em" class="text-lg font-bold fill-current text-[var(--text-primary)]">${Math.round(progress)}%</text>
                         </svg>
                    </div>
                    <div class="flex-grow space-y-2 text-sm mt-2 overflow-y-auto pr-2">
                        ${taskListHTML}
                    </div>
                    <div class="mt-2 flex-shrink-0">
                        <input type="text" id="quick-add-task" placeholder="+ Add a task" class="w-full bg-transparent border-t border-[var(--border-color)]/50 pt-2 text-sm focus:outline-none">
                    </div>
                </div>`;
             }}, 
             projects: { name: "Projects", size: 'col-span-2', render: async () => {
                const projects = await dbAction(PROJECTS_STORE, 'readonly', store => store.getAll());
                if(projects.length === 0) return `<p class="text-sm text-[var(--text-secondary)]">No active projects.</p>`;
                return `<div class="text-left w-full space-y-2 text-sm">
                    <h3 class="font-bold text-base mb-2">Active Projects</h3>
                    ${projects.slice(0,2).map(p => {
                        const completedTasks = p.tasks.filter(t => t.completed).length;
                        const progress = p.tasks.length > 0 ? (completedTasks / p.tasks.length) * 100 : 0;
                        return `<div>
                            <div class="flex justify-between items-center mb-1">
                                <p class="font-semibold">${p.name}</p>
                                <p class="text-xs text-[var(--text-secondary)]">${completedTasks}/${p.tasks.length}</p>
                            </div>
                            <div class="w-full bg-black/20 rounded-full h-1.5"><div class="bg-[var(--accent)] h-1.5 rounded-full" style="width: ${progress}%"></div></div>
                        </div>`
                    }).join('')}
                </div>`
             }},
 			 quickNote: { name: "Quick Note", size: 'col-span-2', render: async () => {
                const note = await dbAction(QUICK_NOTES_STORE, 'readonly', store => store.get('main')) || {content: ''};
                return `<textarea id="quick-note-textarea" class="w-full h-full bg-transparent text-sm p-2 focus:outline-none resize-none" placeholder="Jot something down...">${note.content}</textarea>`;
             }},
             dailyFocus: { name: "Daily Focus", render: async () => {
                const focus = await dbAction(SETTINGS_STORE, 'readonly', store => store.get('dailyFocus')) || { text: '' };
                return `<input type="text" id="daily-focus-input" value="${focus.text}" placeholder="What's your focus today?" class="w-full bg-transparent text-center font-semibold text-lg focus:outline-none">`;
             }},
 		 }; 
          async function getWeatherData() {
            const OPENWEATHER_API_KEY = 'a5a2eab3f48a1b504990e5d0a133e9b0';
            if (localStorage.getItem('locationPermission') !== 'granted') return 'denied';

            try {
                const position = await new Promise((resolve, reject) => navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 10000 }));
                const { latitude, longitude } = position.coords;
                const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&appid=${OPENWEATHER_API_KEY}&units=imperial`);
                if(!response.ok) throw new Error('Weather API failed');
                const data = await response.json();
                return {
                    temp: Math.round(data.main.temp),
                    description: data.weather[0].description,
                    icon: `https://openweathermap.org/img/wn/${data.weather[0].icon}@2x.png`
                };
            } catch (error) {
                console.error("Could not fetch weather data:", error);
                return null;
            }
        }
 		 async function renderWidgets() { 
 			 const grid = document.getElementById('widget-grid'); 
 			 grid.innerHTML = ''; 
 			 const widgetLayout = await dbAction(WIDGET_STORE, 'readonly', store => store.get('layout')); 
 			 let userWidgets = widgetLayout?.value || ['tasks', 'weather', 'irisBrief', 'projects']; 
 			 
 			 const renderPromises = userWidgets.map(async (widgetId, index) => { 
 				 const widgetDef = ALL_WIDGETS[widgetId]; 
 				 if (!widgetDef) return null; 
 				 const widgetEl = document.createElement('div'); 
 				 widgetEl.className = `widget p-4 rounded-lg min-h-[120px] flex items-center justify-center text-center relative ${widgetDef.size || 'col-span-1'}`; 
 				 if (widgetId === 'media' || widgetId === 'notesGrid') widgetEl.className += ' p-2'; 
 				 widgetEl.dataset.widgetId = widgetId; 
 				 widgetEl.style.animationDelay = `${index * 50}ms`; 
 				 
 				 const content = await widgetDef.render(); 
 				 let configBtn = widgetDef.configurable ? `<button data-widget-id="${widgetId}" class="widget-config-btn p-1 rounded-full hover:bg-white/10"><i data-lucide="settings-2" class="w-4 h-4"></i></button>` : ''; 
 				 widgetEl.innerHTML = `<div class="w-full h-full flex items-center justify-center">${content || ''}</div>${configBtn}`; 
 				 return widgetEl; 
 			 }); 
 			 const renderedWidgets = await Promise.all(renderPromises); 
 			 renderedWidgets.forEach(el => { if(el) grid.appendChild(el); }); 

 			 lucide.createIcons(); 
             const quickAddInput = document.getElementById('quick-add-task');
             if(quickAddInput) {
                quickAddInput.addEventListener('keypress', e => {
                    if (e.key === 'Enter' && e.target.value.trim()) {
                        createTask(e.target.value.trim());
                        e.target.value = '';
                    }
                })
             }
             const dailyFocusInput = document.getElementById('daily-focus-input');
             if(dailyFocusInput) {
                dailyFocusInput.addEventListener('blur', e => dbAction(SETTINGS_STORE, 'readwrite', store => store.put({ key: 'dailyFocus', text: e.target.value })))
             }
 		 } 
 		 async function toggleTaskCompletion(taskId, isCompleted, projectId = null) {
            if (projectId) {
                const project = await dbAction(PROJECTS_STORE, 'readonly', store => store.get(parseInt(projectId)));
                if (project) {
                    const task = project.tasks.find(t => t.id === taskId);
                    if(task) task.completed = isCompleted;
                    await dbAction(PROJECTS_STORE, 'readwrite', store => store.put(project));
                }
            } else {
                 const task = await dbAction(TASKS_STORE, 'readonly', store => store.get(taskId));
                if (task) {
                    const updatedTask = { ...task, completed: isCompleted };
                    await dbAction(TASKS_STORE, 'readwrite', store => store.put(updatedTask));
                }
            }
            await refreshApp();
         } 
 		 async function populateWidgetModal() { 
 			 const activeList = document.getElementById('active-widgets-list'); 
 			 const availableList = document.getElementById('available-widgets-list'); 
 			 activeList.innerHTML = '';  
 			 availableList.innerHTML = ''; 
 			 const widgetLayout = await dbAction(WIDGET_STORE, 'readonly', store => store.get('layout')); 
 			 const userWidgets = widgetLayout?.value || ['tasks', 'weather', 'irisBrief', 'projects']; 
 			 Object.keys(ALL_WIDGETS).forEach(id => { 
 				 const item = document.createElement('div'); 
 				 item.className = 'p-2 bg-[var(--surface)] rounded cursor-move'; 
 				 item.textContent = ALL_WIDGETS[id].name; 
 				 item.dataset.widgetId = id; 
 				 if (userWidgets.includes(id)) activeList.appendChild(item); 
 				 else availableList.appendChild(item); 
 			 }); 
 			 Sortable.create(activeList, { group: 'widgets', animation: 150, ghostClass: 'sortable-ghost' }); 
 			 Sortable.create(availableList, { group: 'widgets', animation: 150, ghostClass: 'sortable-ghost' }); 
 		 } 
 		 async function saveWidgetLayout() { 
            const activeList = document.getElementById('active-widgets-list');
            const activeWidgetIds = [...activeList.children].map(item => item.dataset.widgetId);
            await dbAction(WIDGET_STORE, 'readwrite', store => store.put({ id: 'layout', value: activeWidgetIds }));
            closeModal('widget-settings-modal');
            await renderWidgets();
            hapticFeedback('medium');
         } 

 		 async function openWidgetConfigModal(widgetId) {
            const titleEl = document.getElementById('widget-config-title');
            const contentEl = document.getElementById('widget-config-content');
            const saveBtn = document.getElementById('save-widget-config-btn');
            contentEl.innerHTML = ''; 

            titleEl.textContent = `Configure ${ALL_WIDGETS[widgetId].name}`;

            switch (widgetId) {
                case 'countdown':
                    const currentCountdown = await dbAction(SETTINGS_STORE, 'readonly', store => store.get('countdown')) || {};
                    contentEl.innerHTML = `
                        <div>
                            <label for="countdown-event" class="block text-sm font-medium text-[var(--text-secondary)]">Event Name</label>
                            <input type="text" id="countdown-event" value="${currentCountdown.event || ''}" class="mt-1 w-full bg-transparent p-2 rounded border border-[var(--border-color)] focus:outline-none focus:border-[var(--accent)]">
                        </div>
                        <div>
                            <label for="countdown-date" class="block text-sm font-medium text-[var(--text-secondary)]">Target Date</label>
                            <input type="date" id="countdown-date" value="${currentCountdown.date || ''}" class="mt-1 w-full bg-transparent p-2 rounded border border-[var(--border-color)] focus:outline-none focus:border-[var(--accent)]" style="color-scheme: dark;">
                        </div>
                    `;
                    saveBtn.onclick = async () => {
                        const event = document.getElementById('countdown-event').value;
                        const date = document.getElementById('countdown-date').value;
                        await dbAction(SETTINGS_STORE, 'readwrite', store => store.put({ key: 'countdown', event, date }));
                        closeModal('widget-config-modal');
                        await refreshApp();
                    };
                    break;
                case 'weather':
                     contentEl.innerHTML = `<p class="text-sm">Weather widget uses your browser's location. If it's not working, please grant location permission in your browser settings.</p>`;
                     saveBtn.onclick = () => closeModal('widget-config-modal');
                     break;
                default:
                    contentEl.innerHTML = `<p>This widget has no settings.</p>`;
                    saveBtn.onclick = () => closeModal('widget-config-modal');
                    break;
            }
            showModal('widget-config-modal');
        } 

 		 // --- AI ASSISTANT --- 
 		 let recognition, audioContext, analyser, micStream; 
 		 function setupSpeechRecognition() { /* ... implementation ... */ } 
 		 function setupAIVisualizer() { /* ... implementation ... */ } 
 		 function handleAIFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onloadend = () => {
                aiImageBase64 = reader.result.split(',')[1];
                aiImageMimeType = file.type;
                
                const previewContainer = document.getElementById('ai-image-preview-container');
                previewContainer.innerHTML = `<div class="image-preview-container">
                    <img src="${reader.result}" />
                    <button class="image-preview-remove-btn"><i data-lucide="x" class="w-4 h-4"></i></button>
                </div>`;
                lucide.createIcons();
                
                previewContainer.querySelector('.image-preview-remove-btn').addEventListener('click', () => {
                    aiImageBase64 = null;
                    aiImageMimeType = null;
                    previewContainer.innerHTML = '';
                    document.getElementById('ai-file-input').value = '';
                });
            };
            reader.readAsDataURL(file);
        }
 		 async function processCommand(commandText) {  
 			 const aiInputContainer = document.getElementById('ai-input-container'); 
 			 const aiInput = document.getElementById('ai-input'); 
 			 if (!commandText.trim()) return; 
 			 const userQueryForHistory = commandText; 
 			 aiInput.placeholder = "Thinking..."; aiInput.disabled = true; 
 			 aiInputContainer.classList.add('is-thinking'); 

 			 const systemPrompt = `You are Iris, a highly intelligent and decisive AI assistant. Your primary goal is to directly execute user commands by interpreting their intent accurately. Avoid asking for clarification unless the user's request is completely ambiguous or missing critical information (like a time for a reminder). The current date is ${new Date().toLocaleDateString()}. Respond ONLY in the specified JSON format.

Intents:
- 'create_task': For creating one or more tasks. 'details' must contain a 'tasks' array of strings and a 'short_reply'.
- 'delete_task': For removing a task. 'details' contains the 'text' of the task and a 'short_reply'.
- 'create_note': For timeline entries. 'details' contains 'full_response' and a 'short_reply'.
- 'create_grid_note': For grid notes. 'details' contains 'full_response' and a 'short_reply'.
- 'create_project': For new projects. 'details' contains the 'name' of the project and a 'short_reply'.
- 'edit_project': For adding details to a project. 'details' contains 'name' and 'description'.
- 'general_query': For general questions. 'details' contains 'full_response' and a 'short_reply'.
- 'clarification': Use this ONLY as a last resort when the command is impossible to understand. 'details' contains a 'question' and an array of up to 2 'quick_replies'.
- Other intents: 'set_reminder', 'set_countdown', 'export_data', 'add_task_to_project'.

Context from previous turn (if any):
${conversationHistory.map(h => `${h.role}: ${h.parts[0].text}`).join('\n')}

Decisive Examples:
- User: "remind me to take out the trash at 5pm" -> {"intent": "set_reminder", "details": {"text": "take out the trash", "time": "17:00", "short_reply": "Reminder set for 5pm."}}
- User: "add buy milk and walk the dog to my list" -> {"intent": "create_task", "details": {"tasks": ["buy milk", "walk the dog"], "short_reply": "I've added 2 tasks."}}
- User: "i need to do laundry" -> {"intent": "create_task", "details": {"tasks": ["do laundry"], "short_reply": "I've added 'do laundry' to your tasks."}}
- User: "create a project for the new marketing campaign" -> {"intent": "create_project", "details": {"name": "New Marketing Campaign", "short_reply": "Project 'New Marketing Campaign' created."}}
- User: "make a note that we should focus on video content" -> {"intent": "create_grid_note", "details": {"full_response": "Focus on video content for the next quarter.", "short_reply": "I've added that to your notes."}}
- User: "add a description to the marketing campaign project" -> {"intent": "clarification", "details": {"question": "What should the description be?", "quick_replies": []}}

Respond ONLY with the JSON object. Do not add any text before or after the JSON object.`;
 
 			 let parts = [{ "text": commandText }];
             if (aiImageBase64 && aiImageMimeType) {
                 parts.push({ "inlineData": { "mimeType": aiImageMimeType, "data": aiImageBase64 } });
             }
 
 			 const payload = {
                  "contents": [{"parts": parts}],
                  "systemInstruction": { "parts": [{"text": systemPrompt }] }
              };
 
 			 try { 
 				 const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`, { 
                      method: 'POST', 
                      headers: { 'Content-Type': 'application/json' }, 
                      body: JSON.stringify(payload) 
                  }); 
 				 if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`); 
 				 const result = await response.json(); 
                  
                 if (!result.candidates || !result.candidates[0].content.parts[0].text) {
                    throw new Error("Invalid response structure from API");
                 }
                 const rawText = result.candidates[0].content.parts[0].text;
                 let parsedResponse;
                 try {
                     const jsonString = rawText.replace(/```json|```/g, '').trim();
                     parsedResponse = JSON.parse(jsonString);
                 } catch (e) {
                     console.error("Failed to parse JSON from AI, treating as general query. Error:", e);
                     parsedResponse = { intent: 'general_query', details: { full_response: rawText, short_reply: 'Here is what I found:' } };
                 }
 				 handleAIResponse(parsedResponse, userQueryForHistory); 
 			 } catch (error) { 
 				 console.error("Error processing AI command:", error); 
 				 showAIReply("Sorry, I had trouble with that request."); 
 			 } finally { 
 				 aiInput.value = ''; aiInput.disabled = false; aiInput.placeholder = "Talk to Iris..."; 
 				 aiInputContainer.classList.remove('is-thinking'); 
 				 document.getElementById('ai-image-preview-container').innerHTML = ''; 
 				 aiImageBase64 = null; aiImageMimeType = null; 
 			 } 
 		 } 
 		 function handleAIResponse(response, userQuery) { 
 			 if (!response || !response.intent) {
                showAIReply("Sorry, I couldn't understand the command.");
                return;
             }
             const { intent, details } = response;
             const isAction = ['create_task', 'delete_task', 'set_reminder', 'create_note', 'create_grid_note', 'create_project', 'edit_project', 'set_countdown', 'export_data', 'add_task_to_project'].includes(intent);

 			 switch (intent) { 
 				 case 'create_task': 
                    if (details?.tasks && details.tasks.length > 0) { 
                        details.tasks.forEach(taskText => createTask(taskText));
                        showAIReply(details.short_reply || `Added ${details.tasks.length} task(s).`);
                    } else { showAIReply("Sorry, I didn't get the task details."); }
                    break; 
 				 case 'delete_task': 
                    if (details?.text) { deleteTask(details.text); }
                    else { showAIReply("Sorry, I didn't get which task to delete."); }
                    break; 
 				 case 'set_reminder': 
                    if (details?.text && details?.time) { setReminder(details.text, details.time); }
                    else { showAIReply("Sorry, I missed the details for the reminder."); }
                    break; 
 				 case 'create_note': 
                    if (details?.full_response) { saveMoment(true, details.full_response); showAIReply(details.short_reply || "I've saved that as a moment."); }
                    else { showAIReply("Sorry, I didn't get the content for the note."); }
                    break; 
 				 case 'general_query': 
                    const aiResponseText = details?.full_response || "I'm not sure how to respond.";
                    saveToChatHistory(userQuery, aiResponseText); 
                    if (conversationHistory.length < 2) showAIReply(details.short_reply || "I've added my response to our chat.", { animateToChat: true });
                    showView('chat-view');
                    break;
                 case 'clarification':
                    if (details?.question) {
                        pendingAICommand = userQuery;
                        showAIReply(details.question, { quickReplies: details.quick_replies || ['Yes', 'No'] });
                    }
                    break;
 				 case 'set_countdown': 
                    if(details?.event && details?.date) { setCountdown(details.event, details.date); }
                    else { showAIReply("Sorry, I missed the details for the countdown."); }
                    break; 
                 case 'export_data': exportToPDF(); break;
                 case 'create_project': 
                    if (details?.name) { createProject(details.name); showAIReply(details.short_reply || `Project "${details.name}" created.`);}
                    else { showAIReply("What should I name the project?"); }
                    break;
                 case 'edit_project':
                    if (details?.name && details?.description) { editProject(details.name, details.description); }
                    else { showAIReply("I need a project name and a description to add."); }
                    break;
                 case 'add_task_to_project':
                    if (details?.projectName && details?.taskText) { addTaskToProject(details.projectName, details.taskText); }
                    else { showAIReply("I need a project name and a task to add."); }
                    break;
                 case 'create_grid_note':
                    if (details?.full_response) { createGridNote(details.full_response); showAIReply(details.short_reply || 'Note added to your grid.'); }
                    else { showAIReply("What should the note say?"); }
                    break;
 				 default: showAIReply("I didn't understand that command."); 
 			 }
             if (isAction) {
                conversationHistory = []; // Reset context after a clear action
             }
 		 } 
          async function handleQuickReply(reply) {
            if (!pendingAICommand) return;
            const fullCommand = `${pendingAICommand} (User's answer: ${reply})`;
            document.getElementById('ai-reply-popup').classList.remove('is-visible');
            pendingAICommand = null;
            await processCommand(fullCommand);
        }
 		 async function setReminder(text, timeStr) { 
 			 if (Notification.permission !== 'granted') { showAIReply("Please enable notifications first."); return; } 
 			 if (!timeStr) { showAIReply("I need a specific time for the reminder."); return; } 
 			 const [hours, minutes] = timeStr.split(':').map(Number); 
 			 const now = new Date(); 
 			 const reminderTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, 0, 0); 
 			 if (reminderTime < now) reminderTime.setDate(reminderTime.getDate() + 1); 
 			 const delay = reminderTime.getTime() - now.getTime(); 
 			 setTimeout(() => { new Notification('Iris Space Reminder', { body: text, icon: 'https://placehold.co/192x192/0891b2/ffffff?text=IS' }); }, delay); 
            showAIReply(`Reminder set for ${timeStr}.`);
 		 } 
 		 async function createTask(text) { await dbAction(TASKS_STORE, 'readwrite', store => store.add({ text, completed: false, createdAt: Date.now() })); await refreshApp(); } 
 		 async function deleteTask(text) { 
            if (!text) {
                showAIReply("Please tell me which task to remove.");
                return;
            }
            const tasks = await dbAction(TASKS_STORE, 'readonly', store => store.getAll());
            const taskToDelete = tasks.find(task => task.text.toLowerCase() === text.toLowerCase());

            if (taskToDelete) {
                await dbAction(TASKS_STORE, 'readwrite', store => store.delete(taskToDelete.id));
                await refreshApp();
                showAIReply(`Task "${text}" has been removed.`);
            } else {
                showAIReply(`I couldn't find the task "${text}".`);
            }
        } 
 		 async function setCountdown(event, date) { await dbAction(SETTINGS_STORE, 'readwrite', store => store.put({ key: 'countdown', event, date })); await refreshApp(); showAIReply(`Countdown set for ${event}.`); } 

 		 // --- NOTIFICATIONS ---
        async function checkNotifications() {
            if (!('Notification' in window) || Notification.permission !== 'granted') return;
            const tasks = await dbAction(TASKS_STORE, 'readonly', store => store.getAll());
            const now = Date.now();
            const twelveHours = 12 * 60 * 60 * 1000;
            tasks.forEach(async task => {
                if (!task.completed && !task.notificationSent && task.createdAt && (now - task.createdAt > twelveHours)) {
                    new Notification('Iris Space: Task Overdue', {
                        body: `Your task "${task.text}" is over 12 hours old.`,
                        icon: 'https://placehold.co/192x192/0891b2/ffffff?text=IS'
                    });
                    const updatedTask = { ...task, notificationSent: true };
                    await dbAction(TASKS_STORE, 'readwrite', store => store.put(updatedTask));
                }
            });
        }

        // --- EXPORT ---
        async function exportToPDF() {
            showAIReply("Generating your PDF...");
            const moments = await dbAction(MOMENTS_STORE, 'readonly', store => store.getAll());
            moments.sort((a,b) => a.timestamp - b.timestamp);

            const doc = new jsPDF();
            let yPos = 15;
            const pageHeight = doc.internal.pageSize.height;
            const margin = 10;

            doc.setFont("helvetica", "bold");
            doc.setFontSize(20);
            doc.text("Iris Space - Moments Export", margin, yPos);
            yPos += 10;

            moments.forEach(m => {
                if (yPos > pageHeight - 30) {
                    doc.addPage();
                    yPos = margin;
                }

                doc.setFont("helvetica", "bold");
                doc.setFontSize(10);
                doc.text(new Date(m.timestamp).toLocaleString(), margin, yPos);
                yPos += 7;

                if (m.text) {
                    doc.setFont("helvetica", "normal");
                    doc.setFontSize(12);
                    const splitText = doc.splitTextToSize(m.text, doc.internal.pageSize.width - margin * 2);
                    doc.text(splitText, margin, yPos);
                    yPos += (splitText.length * 5) + 3;
                }
                
                if (m.tags && m.tags.length > 0) {
                    doc.setFont("helvetica", "italic");
                    doc.setFontSize(9);
                    doc.setTextColor(100);
                    doc.text(`Tags: ${m.tags.join(', ')}`, margin, yPos);
                    yPos += 8;
                    doc.setTextColor(0);
                }
                
                yPos += 5; 
                doc.setDrawColor(200);
                doc.line(margin, yPos, doc.internal.pageSize.width - margin, yPos);
                yPos += 7;
            });
            
            doc.save("iris-space-export.pdf");
            showAIReply("Your PDF has been downloaded.");
        }

 		 // --- OTHER PAGES --- 
 		 async function renderProjects() {
            const container = document.getElementById('projects-container');
            container.innerHTML = `<h2 class="title-font text-3xl font-bold mb-6">Projects</h2>`;
            const projects = await dbAction(PROJECTS_STORE, 'readonly', store => store.getAll());
            if (projects.length === 0) {
                container.innerHTML += `<div class="text-center mt-20 text-[var(--text-secondary)]"><i data-lucide="folder-kanban" class="w-16 h-16 mx-auto"></i><p class="mt-4">No projects yet. Ask Iris to create one!</p></div>`;
                lucide.createIcons();
                return;
            }
            projects.forEach((p, index) => {
                const completedTasks = p.tasks.filter(t => t.completed).length;
                const progress = p.tasks.length > 0 ? (completedTasks / p.tasks.length) * 100 : 0;
                const card = document.createElement('div');
                card.className = 'project-card p-4 rounded-lg';
                card.dataset.projectId = p.id;
                card.style.animationDelay = `${index * 50}ms`;
                card.innerHTML = `
                    <div class="flex justify-between items-start">
                        <h3 class="font-bold text-lg">${p.name}</h3>
                        <span class="text-sm font-semibold">${Math.round(progress)}%</span>
                    </div>
                    <p class="text-xs text-[var(--text-secondary)] mt-1 mb-3 truncate">${p.description || 'No description'}</p>
                    <div class="w-full bg-black/20 rounded-full h-2 "><div class="bg-[var(--accent)] h-2 rounded-full" style="width: ${progress}%"></div></div>
                `;
                container.appendChild(card);
            });
            lucide.createIcons();
        }

        async function renderNotes() {
            const container = document.getElementById('notes-container');
            container.innerHTML = `<h2 class="title-font text-3xl font-bold mb-6 col-span-full">Notes</h2>`;
            const notes = await dbAction(NOTES_STORE, 'readonly', store => store.getAll());
            notes.sort((a,b) => b.timestamp - a.timestamp);
            if (notes.length === 0) {
                container.innerHTML += `<div class="text-center mt-20 text-[var(--text-secondary)] col-span-full"><i data-lucide="notebook-pen" class="w-16 h-16 mx-auto"></i><p class="mt-4">Your notes grid is empty.</p></div>`;
                lucide.createIcons();
                return;
            }
            notes.forEach((note, index) => {
                const item = document.createElement('div');
                item.className = 'note-item p-4 rounded-lg min-h-[150px]';
                item.dataset.noteId = note.id;
                item.style.animationDelay = `${index * 50}ms`;
                item.innerHTML = `<p class="text-sm whitespace-pre-wrap">${note.content}</p>`;
                container.appendChild(item);
            });
        }

        async function createProject(name) {
            await dbAction(PROJECTS_STORE, 'readwrite', store => store.add({ name, description: '', tasks: [] }));
            await refreshApp();
            showView('projects-view');
        }

        async function editProject(projectName, description) {
            const projects = await dbAction(PROJECTS_STORE, 'readonly', store => store.getAll());
            const project = projects.find(p => p.name.toLowerCase() === projectName.toLowerCase());
            if(project) {
                project.description = description;
                await dbAction(PROJECTS_STORE, 'readwrite', store => store.put(project));
                await refreshApp();
                showAIReply(`Updated description for "${projectName}".`);
            } else {
                showAIReply(`I couldn't find a project named "${projectName}".`);
            }
        }

        async function addTaskToProject(projectName, taskText) {
            const projects = await dbAction(PROJECTS_STORE, 'readonly', store => store.getAll());
            const project = projects.find(p => p.name.toLowerCase() === projectName.toLowerCase());
            if (project) {
                const newTask = { id: Date.now(), text: taskText, completed: false }; 
                project.tasks.push(newTask);
                await dbAction(PROJECTS_STORE, 'readwrite', store => store.put(project));
                await refreshApp();
                showAIReply(`Added task to "${projectName}".`);
                showView('projects-view');
            } else {
                showAIReply(`Could not find a project named "${projectName}".`);
            }
        }
        
        async function createGridNote(content) {
            await dbAction(NOTES_STORE, 'readwrite', store => store.add({ content, timestamp: Date.now() }));
            await refreshApp();
            showView('notes-view');
        }

         async function performSearch(query) {
            const resultsContainer = document.getElementById('search-results');
            if (!query || query.length < 2) {
                resultsContainer.innerHTML = '';
                return;
            }
            const lowerQuery = query.toLowerCase();
            const [moments, notes, projects] = await Promise.all([
                dbAction(MOMENTS_STORE, 'readonly', store => store.getAll()),
                dbAction(NOTES_STORE, 'readonly', store => store.getAll()),
                dbAction(PROJECTS_STORE, 'readonly', store => store.getAll())
            ]);
            let resultsHTML = '';
            moments.filter(m => m.text?.toLowerCase().includes(lowerQuery) || m.tags?.some(t => t.toLowerCase().includes(lowerQuery))).forEach(m => {
                resultsHTML += `<div class="search-result-item p-3 bg-black/20 rounded-lg cursor-pointer" data-type="moment" data-id="${m.id}"><p class="font-bold text-sm">Moment</p><p class="text-xs text-[var(--text-secondary)]">${m.text.substring(0,100)}...</p></div>`;
            });
            notes.filter(n => n.content.toLowerCase().includes(lowerQuery)).forEach(n => {
                resultsHTML += `<div class="search-result-item p-3 bg-black/20 rounded-lg cursor-pointer" data-type="note" data-id="${n.id}"><p class="font-bold text-sm">Note</p><p class="text-xs text-[var(--text-secondary)]">${n.content.substring(0,100)}...</p></div>`;
            });
            projects.filter(p => p.name.toLowerCase().includes(lowerQuery)).forEach(p => {
                resultsHTML += `<div class="search-result-item p-3 bg-black/20 rounded-lg cursor-pointer" data-type="project" data-id="${p.id}"><p class="font-bold text-sm">Project</p><p class="text-xs text-[var(--text-secondary)]">${p.name}</p></div>`;
            });

            resultsContainer.innerHTML = resultsHTML || `<p class="text-center text-sm text-[var(--text-secondary)]">No results found.</p>`;
         }

         function handleSearchResultClick(dataset) {
            const { type, id } = dataset;
            closeModal('search-modal');
            if (type === 'note') openNoteView(parseInt(id));
            if (type === 'project') openProjectView(parseInt(id));
            if (type === 'moment') showView('timeline-view'); // Simple navigation for now
         }

         async function openNoteView(noteId) {
            const view = document.getElementById('note-detail-view');
            const isNew = noteId === null;
            const note = isNew ? { content: '', id: null } : await dbAction(NOTES_STORE, 'readonly', store => store.get(noteId));
            if (!note) return;

            view.innerHTML = `<div class="p-4 border-b border-[var(--border-color)] flex justify-between items-center"><h2 class="title-font text-xl">${isNew ? 'Create Note' : 'Edit Note'}</h2><button id="close-note-view"><i data-lucide="x"></i></button></div><div class="p-4 flex-grow flex flex-col"><textarea id="note-detail-textarea" class="w-full h-full flex-grow bg-transparent p-2 rounded border border-[var(--border-color)] focus:outline-none focus:border-[var(--accent)]">${note.content}</textarea></div><div class="p-4 border-t border-[var(--border-color)] flex justify-between"><button id="delete-note-btn" class="px-4 py-2 text-red-400 rounded font-semibold hover:bg-red-400/10 transition" style="display: ${isNew ? 'none': 'block'}">Delete</button><button id="save-note-btn" class="px-4 py-2 bg-[var(--accent)] text-black rounded font-semibold hover:opacity-80 transition">Save Changes</button></div></div>`;
            lucide.createIcons();

            document.getElementById('save-note-btn').onclick = () => saveNote(note.id);
            document.getElementById('delete-note-btn').onclick = () => deleteNote(note.id);
            document.getElementById('close-note-view').onclick = () => showView('notes-view');
            showView('note-detail-view');
         }

         async function saveNote(noteId) {
            const newContent = document.getElementById('note-detail-textarea').value;
            if (!newContent) return;

            if (noteId) {
                const note = await dbAction(NOTES_STORE, 'readonly', store => store.get(noteId));
                if(note) {
                    const updatedNote = { ...note, content: newContent };
                    await dbAction(NOTES_STORE, 'readwrite', store => store.put(updatedNote));
                }
            } else {
                await dbAction(NOTES_STORE, 'readwrite', store => store.add({ content: newContent, timestamp: Date.now() }));
            }
            showView('notes-view');
            await renderNotes();
         }

         async function deleteNote(noteId) {
            await dbAction(NOTES_STORE, 'readwrite', store => store.delete(noteId));
            showView('notes-view');
            await renderNotes();
         }

         async function openProjectView(projectId) {
            const project = await dbAction(PROJECTS_STORE, 'readonly', store => store.get(projectId));
            if (!project) return;
            const view = document.getElementById('project-detail-view');
            
            view.innerHTML = `<div class="p-4 border-b border-[var(--border-color)] flex justify-between items-center"><input id="project-detail-title-input" class="title-font text-xl bg-transparent focus:outline-none w-full" value="${project.name}"><button id="close-project-view"><i data-lucide="x"></i></button></div><div class="p-4 flex-grow flex flex-col gap-4"><textarea id="project-detail-desc" placeholder="Add a description..." class="w-full h-24 bg-transparent p-2 rounded border border-[var(--border-color)] focus:outline-none focus:border-[var(--accent)] text-sm">${project.description || ''}</textarea><div id="project-detail-tasks" class="flex-grow overflow-y-auto space-y-2"></div></div><div class="p-4 border-t border-[var(--border-color)] flex justify-between"><button id="delete-project-btn" class="px-4 py-2 text-red-400 rounded font-semibold hover:bg-red-400/10 transition">Delete Project</button><button id="save-project-btn" class="px-4 py-2 bg-[var(--accent)] text-black rounded font-semibold hover:opacity-80 transition">Save Changes</button></div></div>`;
            
            const contentEl = view.querySelector('#project-detail-tasks');
            contentEl.innerHTML = project.tasks.map(t => `
                <div class="flex items-center gap-2 text-sm p-2 rounded-md hover:bg-white/5">
                    <input type="checkbox" data-task-id="${t.id}" data-project-id="${projectId}" class="task-checkbox accent-[var(--accent)]" ${t.completed ? 'checked' : ''}>
                    <label class="${t.completed ? 'line-through text-[var(--text-secondary)]' : ''}">${t.text}</label>
                </div>
            `).join('');

            lucide.createIcons();
            view.querySelector('#save-project-btn').onclick = () => saveProject(projectId);
            view.querySelector('#delete-project-btn').onclick = () => deleteProject(projectId);
            view.querySelector('#close-project-view').onclick = () => showView('projects-view');
            showView('project-detail-view');
         }

         async function saveProject(projectId) {
            const project = await dbAction(PROJECTS_STORE, 'readonly', store => store.get(projectId));
            if (!project) return;
            project.name = document.getElementById('project-detail-title-input').value;
            project.description = document.getElementById('project-detail-desc').value;
            await dbAction(PROJECTS_STORE, 'readwrite', store => store.put(project));
            showView('projects-view');
            await renderProjects();
         }

         async function deleteProject(projectId) {
            await dbAction(PROJECTS_STORE, 'readwrite', store => store.delete(projectId));
            showView('projects-view');
            await renderProjects();
         }

         // --- GOOGLE CALENDAR INTEGRATION ---
         function handleClientLoad() {
            gapi.load('client', gapiInit);
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: 'https://www.googleapis.com/auth/calendar.events',
                callback: (tokenResponse) => {
                    if (tokenResponse && tokenResponse.access_token) {
                        localStorage.setItem('google_token', tokenResponse.access_token);
                        refreshApp();
                    }
                },
            });
         }

         async function gapiInit() {
            try {
                await gapi.client.init({
                    apiKey: GOOGLE_API_KEY,
                    discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest"],
                });
                gapiInited = true;
            } catch(e) { console.error("Error initializing GAPI client", e); }
         }

         function handleAuthClick() {
            if (gapiInited && tokenClient) {
                tokenClient.requestAccessToken();
            } else {
                console.error("Google API clients not ready.");
            }
         }

         function handleSignoutClick() {
            const token = localStorage.getItem('google_token');
            if (token) {
                google.accounts.oauth2.revoke(token, () => {
                    localStorage.removeItem('google_token');
                    gapi.client.setToken(null);
                    refreshApp();
                });
            }
         }

         async function createGoogleCalendarEvent(task) {
            if (!localStorage.getItem('google_token')) return;
            gapi.client.setToken({ access_token: localStorage.getItem('google_token') });
            
            const event = {
                'summary': task.text,
                'start': {
                    'dateTime': task.dateTime,
                    'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone,
                },
                'end': {
                    'dateTime': new Date(new Date(task.dateTime).getTime() + 60 * 60 * 1000).toISOString(), // Assume 1 hour duration
                    'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone,
                },
            };

            try {
                const request = gapi.client.calendar.events.insert({
                    'calendarId': 'primary',
                    'resource': event,
                });
                await request.execute();
                console.log('Event created:', event.summary);
            } catch (err) { console.error('Error creating Google Calendar event:', err); }
         }

 	 </script> 
 </body> 
 </html>
